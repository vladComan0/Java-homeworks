/*Write a Java program that defines an array 
of double values and read the appropriate data from the keyboard. 
Handle the exception produced when the code tries to acces an 
element that has a negative index or an index greater than the
maximum number of elements (ArrayIndexOutOfBoundsException).
Display a significant message when the exception occurs.
Consider a matrix with a fixed number of elements for each line 
and protect the code against the exception mentioned
above. Consider also the case if each line has a different number of elements.
Vlad Coman, Group 2024
18.04.2020
*/
package labwork5;
import java.util.Scanner;
public class labwork6 {
    public static void main(String[] args) {
        Double arr[] = new Double[25];
        arr = readArray();
        valueAt(4,arr);
    }
    @SuppressWarnings("resource")
	static Double[] readArray() {
        Scanner cin = new Scanner(System.in);
        try {
            System.out.println("Introduceti nr de elemente: ");
            int n = cin.nextInt();
            cin.nextLine();
            if (n > 25) throw new ArrayIndexOutOfBoundsException("Nu se pot introduce mai mult de 25 de valori!");
            Double[] arr = new Double[n];
            System.out.println("Introduceti noul array: ");
            for (int i = 0; i < n; i++) {
                arr[i] = cin.nextDouble();
            }
            return arr;

        } catch (ArrayIndexOutOfBoundsException ex) {
            ex.printStackTrace();
        }
        Double[] arrayForExits = {0.0};
        return arrayForExits;
    }

    static void valueAt(int index, Double[] array) {
        try{
            if(index<0) throw new ArrayIndexOutOfBoundsException("Nu se pot introduce indecsi negativi!");
            else if(index <=array.length) System.out.println("Elementul de pe pozitia " + index + " este " + array[index]);
            else throw new ArrayIndexOutOfBoundsException("Nu putem avea mai mult de 25 de valori!");
        }
        catch (ArrayIndexOutOfBoundsException ex) {
            ex.printStackTrace();
        }
    }
}


/* Write a Java application which, within the main() method, contains 
 * a squence of code that may throw various exceptions, 
 * such as ArithmeticException, ArrayIndexOutOfBoundsException, 
 * NullPointerException, NumberFormatException, as well as others 
 * which you consider to be useful for testing. 
 * In the catch block show the corresponding message generated by 
 * these exceptions. The finally block just prints the message, 
 * "I may or may not have caught an exception".
Vlad Coman, Group 2024
18.04.2020
*/
package labwork5;
public class labwork06 {
    public static void main(String[] args) {
        try {
            System.out.println("Impartire la 0");
            System.out.println("Impartirea lui 10 la 0. Rezultat: Eroare");
            System.out.println(10/0);
        }
        catch (ArithmeticException ex) {
            System.out.println("Exceptie aritmetica: " + ex);
        }
        finally {
            System.out.println("I may or may not have caught an exception");
        }
        try {
            System.out.println("Element in afara limitei");
            int[] array = {5,3,1,12,11,113};

            System.out.println("Array-ul nostru: ");
            showArray(array);
            System.out.println("Elementul de pe pozitia 5: " + array[5]);
        }
        catch (ArrayIndexOutOfBoundsException ex) {
            System.out.println("ArrayIndexOutOfBounds exception: " + ex);
        }
        finally {
            System.out.println("I may or may not have caught an exception");
        }
        try {
            System.out.println("Obiect null");
            Integer integer = null;
            System.out.println("Obiectul este: " + (integer + 1));
        }
        catch (NullPointerException ex) {
            System.out.println("NullPointer: " + ex);
        }
        finally {
            System.out.println("I may or may not have caught an exception");
        }
    }
    private static void showArray(int[] array) {
        for (Integer it: array) {
            System.out.print(it + " ");
        }
        System.out.println(" ");
    }
}


/* Define a package that declares an interface named Int1 (2 integer 
 * variables and a sum() method that returns the sum
of 2 integer values). Include in the same package a class 
named Class1 (2 protected double variables, constructor, setters
and getters). In another source file, add in the same package 
a new interface named Int2 (2 double variables and a
method named product() that returns the product of 2 double values).
Implement a distinct source file and import everything from 
the defined package. Define a class named Class2 that is
derived from Class1 and implements both interfaces Int1 and Int2.
Instantiate Class2 and call the defined methods for 
determining the sum and product of some values read from thekeyboard
Vlad Coman, Group 2024
18.04.2020
*/
package interfaces;

import java.util.Scanner;

class Class2 extends Class1 implements Int1, Int2{

	Class2(double a, double b) {
		super(a, b);
	}
	Class2(){
		super();
	}
	@Override
	public double product(double a, double b) {
		return a*b;
	}

	@Override
	public int sum(int a, int b) {
		return a+b;
	}
}
public class Main {
	private static Scanner cin;
	public static void main(String []args) {
		cin=new Scanner(System.in);
	Class2 ob1=new Class2();
	double a, b;
	System.out.println("Introduceti a si b (double): ");
	a=cin.nextDouble();
	b=cin.nextDouble();
	int x, y;
	System.out.println("Introduceti x si y (int): ");
	x=cin.nextInt();
	y=cin.nextInt();
	ob1.setA(a);
	ob1.setB(b);
	System.out.println("Produsul numerelor este: "+ob1.product(a, b));
	System.out.println("Suma numerelor este: "+ob1.sum(x, y));
	}
}
package interfaces;

public interface Int1 {
	public static final int a = 0;
	public static final int b = 0;
	public int sum(int a, int b);
}
package interfaces;

public class Class1 {
	protected double a, b;
	Class1(double a, double b){
		this.a=a;
		this.b=b;
	}
	Class1(){
		this.a=0;
		this.b=0;
	}
	public void setA(double a) {
		this.a=a;
	}
	public double getA() {
		return a;
	}
	public void setB(double b) {
		this.b=b;
	}
	public double getB() {
		return b;
	}
}
package interfaces;

public interface Int2 {
	public static final double a=0, b=0;
	public double product(double a, double b);
}


/*  Write a Java class derived from the Exception class, called 
SuperException. Another class, called SmallerException is
derived from SuperException. Within the classes' constructors
print a message which indicates which exception was
generated. In a third class create a method a() which 
throws an exception of type SmallerException, and a method b()
which throws a SuperException. In the main() method call these 
two methods and try to determine the type of exception which 
occurs, as well as if the corresponding catch block for 
the SmallerException can catch a SuperException.
Vlad Coman, Group 2024
18.04.2020
*/
package labwork5;
class SuperException extends Exception{
	SuperException(String str){
		super("S-a generat exceptia din clasa SuperException");
	}
}
class SmallerException extends SuperException{
	SmallerException(String str){
		super("S-a generat exceptia din clasa SmallerException");
	}
}
class Methods{
	public void a() throws SuperException{
		try {
			throw new SuperException("Exceptia s-a generat in clasa SuperException (metoda a)");
		}
		catch(SuperException e) {
			e.printStackTrace();
		}
	}
	public void b() throws SmallerException{
		try {
			throw new SmallerException("Exceptia s-a generat in clasa SmallerException (metoda b)");
		}
		catch(SmallerException e) {
			e.printStackTrace();
	}
}
}
public class labwork06 {
    public static void main(String[] args) throws SuperException {
       Methods ob1=new Methods();
       ob1.a();
       ob1.b();
}
}


/* Write an application which checks if 3 random points form an 
obtuse triangle. If the condition is not met, a specific exception 
is thrown: AcuteTriangle, RightTriangle. If the 3 points are on
the same line or if the segments determined by the 3 points cannot make 
up a triangle, throw an ImpossibleTriangle exception, and within the 
corresponding catch block print a warning and throw a RuntimeException.
Vlad Coman, Group 2024
18.04.2020
*/
package labwork5;
import java.util.Scanner;
import java.lang.Math;
class Point{
	private double x, y;
	Point(){
		this.x=0;
		this.y=0;
	}
	Point(double x, double y){
		this.x=x;
		this.y=y;
	}
	public void setX(double x) {
		this.x=x;
	}
	public double getX() {
		return x;
	}
	public void setY(double y) {
		this.y=y;
	}
	public double getY() {
		return y;
	}
	public double getDistance(Point ob2) {
		double distance;
		distance=Math.sqrt(Math.pow(ob2.x-this.x,2)+Math.pow(ob2.y-this.y, 2));
		return distance;
	}
}
public class labwork06 {
	private static Scanner cin;
    public static void main(String[] args) {
    cin=new Scanner(System.in);
    Point p1=new Point();
    Point p2=new Point();
    Point p3=new Point();
    double x1, x2, x3, y1, y2, y3;
    System.out.println("Introduceti coordonatele pentru primul punct: ");
    System.out.println("x= ");
    x1=cin.nextDouble();
    System.out.println("y= ");
    y1=cin.nextDouble();
    p1.setX(x1);
    p1.setY(y1);
    System.out.println("Introduceti coordonatele pentru cel de-al doilea punct: ");
    System.out.println("x= ");
    x2=cin.nextDouble();
    System.out.println("y= ");
    y2=cin.nextDouble();
    p2.setX(x2);
    p2.setY(y2);
    System.out.println("Introduceti coordonatele pentru cel de-al treilea punct: ");
    System.out.println("x= ");
    x3=cin.nextDouble();
    System.out.println("y= ");
    y3=cin.nextDouble();
    p3.setX(x3);
    p3.setY(y3);
    double d12, d13, d23;
    d12=p1.getDistance(p2);
    d13=p1.getDistance(p3);
    d23=p2.getDistance(p3);
    try {
    	if((p1.getX()==p2.getX() && p1.getX()==p3.getX())||(p1.getY()==p2.getY() && p1.getY()==p3.getY()))
    		System.out.println("Punctele sunt pe aceeasi linie!");
    }catch(RuntimeException e) {
    	System.out.println("Punctele sunt pe aceeasi linie!");
    }
    if(((Math.pow(d12, 2)+Math.pow(d13, 2))<Math.pow(d23, 2))||((Math.pow(d12, 2)+Math.pow(d23, 2))<Math.pow(d13, 2))||((Math.pow(d13, 2)+Math.pow(d23, 2))<Math.pow(d12, 2)))
    		System.out.println("Triunghiul este obtuz!");
    		else 
    			if(((Math.pow(d12, 2)+Math.pow(d13, 2))>Math.pow(d23, 2))||((Math.pow(d12, 2)+Math.pow(d23, 2))>Math.pow(d13, 2))||((Math.pow(d13, 2)+Math.pow(d23, 2))>Math.pow(d12, 2)))
    				System.out.println("Triunghiul este ascutitunghic!");
    			else
    				if(((Math.pow(d12, 2)+Math.pow(d13, 2))==Math.pow(d23, 2))||((Math.pow(d12, 2)+Math.pow(d23, 2))==Math.pow(d13, 2))||((Math.pow(d13, 2)+Math.pow(d23, 2))==Math.pow(d12, 2)))
    					System.out.println("Triunghiul este dreptunghic!");
    }	
}
